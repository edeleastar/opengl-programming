 <!DOCTYPE html>
 <head>

   <meta charset="utf-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
 
   <title> Lighting & Materials </title>
 
   <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
   <link rel="stylesheet" href="./style/semantic/css/semantic.min.css" type="text/css">  
   <link rel="stylesheet" href="./style/custom/main.css" type="text/css"> 
 
   <script src="./style/custom/jquery-2.1.0.min.js"></script> 
   <script src="./style/custom/jquery.address-1.6.min.js"></script>
   <script src="./style/semantic/javascript/semantic.min.js"></script>
 
   <link rel="stylesheet" href="./style/highlight/highlight.css">
 
   <script src="./style/highlight/highlight.js"></script> 
   <script>hljs.initHighlightingOnLoad();</script>
 
   <script src="./style/custom/common.js"> </script> 
   <script src="./style/custom/main.js"> </script> 

</head>
 
 <body>
  <nav class="ui fixed top pointing borderless inverted menu">
    <header class="header item"> <a href="../../index.html">Lighting & Materials</a></header>
    <div class="right tab-menu menu">
          <a class="active item" data-tab="step01"> Objectives </a>
          <a class="item" data-tab="step02"> Setup </a>
          <a class="item" data-tab="step03"> Camera </a>
          <a class="item" data-tab="step04"> Model </a>
          <a class="item" data-tab="step05"> Ambient Lighting </a>
          <a class="item" data-tab="step06"> Normals </a>
          <a class="item" data-tab="step07"> Light Sources </a>
          <a class="item" data-tab="step08"> Material Properties </a>
          <a class="item" data-tab="step09"> Exercises </a>
    </div>
  </nav>

  <br>

	  <section data-tab="step01" class="ui active tab stacked clarity-book segment">
	     <h2>01: Objectives</h2>
<ul>
<li>
<p>Introduce  model of a plane, and render it</p>
</li>
<li>
<p>Colour that model</p>
</li>
<li>
<p>Enable a basic ambient lighting model, and observer the results</p>
</li>
<li>
<p>Introduce normal calculation into our `Vector lass</p>
</li>
<li>
<p>Define a light source, and observe its effect on our plane</p>
</li>
<li>
<p>Encode a range of material properties and explore their visual characteristics</p>
</li>
</ul>
	  </section>
	  <section data-tab="step02" class="ui tab stacked clarity-book segment">
	     <h2>02: Setup</h2>
<ul>
<li>
<p>Clone last week project and call the new one 'lab10_lighting'. Alternatively, you can recover the sources from this archive here:</p>
</li>
<li>
<p><a href="../archives/lab09_camera_colour.zip">lab09_camera_colour.zip</a></p>
</li>
</ul>
	  </section>
	  <section data-tab="step03" class="ui tab stacked clarity-book segment">
	     <h2>03: Camera</h2>
<ul>
<li>
<p>You may have implemented to this already - here is my version:</p>
</li>
<li>
<p><a href="../archives/camera.h">camera.h</a></p>
</li>
<li>
<p><a href="../archives/firstpersoncamera.h">firstpersoncamera.h</a></p>
</li>
<li>
<p><a href="../archives/firstpersoncamera.cpp">firstpersoncamera.cpp</a></p>
</li>
<li>
<p><a href="../archives/thirdpersoncamera.h">thirdpersoncamera.h</a></p>
</li>
<li>
<p><a href="../archives/thirdpersoncamera.cpp">thirdpersoncamera.cpp</a></p>
</li>
<li>
<p>And this is the 'manager' of the cameras:</p>
</li>
<li>
<p><a href="../archives/cameras.h">cameras.h</a></p>
</li>
<li>
<p><a href="../archives/cameras.cpp">cameras.cpp</a></p>
</li>
<li>
<p>World, then holds a 'cameras' object:</p>
</li>
</ul>
<pre><code>  Cameras        cameras;
</code></pre>

<ul>
<li>..and we make sure to pass on the key/mouse events:</li>
</ul>
<pre><code>void World::keyPress(unsigned char ch)
{
  if (ch &gt;= '1' &amp;amp;&amp;amp; ch &lt;= '4')
  {
    projectors.keyPress(ch);
  }
  else if (ch &gt;= '5' &amp;amp;&amp;amp; ch &lt;= '6')
  {
    cameras.keyPress(ch);
  }
  else
  {
    cameras.currentCamera-&gt;keyStroke(ch);
  }
  glutPostRedisplay();
}

void World::specialKeyPress(int key, int x, int y)
{
  if (projectors.isPerspective())
  {
    cameras.currentCamera-&gt;specialKeyboard(key, x, y);
  }
  glutPostRedisplay();
}

void World::mouseMovement(int x, int y)
{
  cameras.currentCamera-&gt;mouseMovement(x,y);
}
</code></pre>
	  </section>
	  <section data-tab="step04" class="ui tab stacked clarity-book segment">
	     <h2>04: Model</h2>
<ul>
<li>
<p>This is the jetmodel geometry again:</p>
</li>
<li>
<p><a href="../archives/jetplanegeometry.h">jetplanegeometry.h</a></p>
</li>
<li>
<p>... and this is the class definition:</p>
</li>
</ul>
<pre><code>#pragma once
#include &quot;actor.h&quot;

struct JetPlane : public  Actor
{
  JetPlane();
  void render();
};
</code></pre>

<ul>
<li>And the implementation:</li>
</ul>
<pre><code>#include &quot;libs.h&quot;
#include &quot;jetplane.h&quot;
#include &quot;Color.h&quot;
#include &quot;jetplanegeometry.h&quot;

using namespace std;

void render (Vector3 vectors[][3], int size)
{
  for (int i=0; i&lt;size; i++)
  {
    glBegin(GL_TRIANGLES);
      vectors[i][0].render();
      vectors[i][1].render();
      vectors[i][2].render();
    glEnd();
  }
}

JetPlane::JetPlane()
{}

void JetPlane::render()
{
  glShadeModel(GL_SMOOTH);
  glPolygonMode(GL_FRONT,GL_FILL);

  Color::Yellow.render();
  ::render(noseCone, 3);
  Color::Red.render();
  ::render(body, 3);
  Color::Green.render();
  ::render(wings, 4);
  Color::Cyan.render();
  ::render(tail, 7);

  Color::White.render();
  glPolygonMode(GL_FRONT,GL_LINE);
}
</code></pre>

<ul>
<li>In scene, we can just create the jet at the origin:</li>
</ul>
<pre><code>Scene:: Scene(Model *model)
{
  foreach (GeometryMap::value_type &amp;amp;value, model-&gt;entities)
  {
    string name = value.first;
    Actor *actor;
    if (name == &quot;cube&quot;)
    {
      actor = new CubeActor(&amp;amp;value.second);
      animateActors[name] = (AnimateActor*) actor;
    }
    else
    {
      actor = new Actor(&amp;amp;value.second);
    }
    actors.insert(name, actor);
  }
  string jet=&quot;jet&quot;;
  actors.insert(jet, new JetPlane());
 }
</code></pre>

<ul>
<li>This should build - and we should see the jet.</li>
</ul>
	  </section>
	  <section data-tab="step05" class="ui tab stacked clarity-book segment">
	     <h2>05: Ambient Lighting</h2>
<ul>
<li>
<p>Lets to some experiments with in world.cpp. </p>
</li>
<li>
<p>The code we introduce is experimental, and not encapsulated in any way. It is primarily to get familiar with the effects of lighting in OpenGL.</p>
</li>
<li>
<p>In World::initalise, enable lighting:</p>
</li>
</ul>
<pre><code>  glEnable(GL_LIGHTING);
</code></pre>

<ul>
<li>
<p>Build and test. Results not impressive, as the plan is now gone (invisible).</p>
</li>
<li>
<p>It is in fact still being rendered, but all in black.</p>
</li>
<li>
<p>In World::render, change black background to blue:</p>
</li>
</ul>
<pre><code>  Color::Blue.renderClear();
</code></pre>

<ul>
<li>
<p>Build and test.</p>
</li>
<li>
<p>Plane is now visible, but completely black.</p>
</li>
<li>
<p>Introduce some ambient light - set this as follows:</p>
</li>
</ul>
<pre><code>  GLfloat  ambientLightFull[] = { 1.0f, 1.0f, 1.0f, 1.0f };
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLightFull);
</code></pre>

<ul>
<li>
<p>Build and test. Still nothing visible.</p>
</li>
<li>
<p>Problem is, we have no material properties set for any of our surfaces.</p>
</li>
<li>
<p>We can try a simple gray material for all surfaces:</p>
</li>
</ul>
<pre><code>  float gray[] =  { 0.75f, 0.75f, 0.75f, 1.0f };
  glMaterialfv(GL_FRONT,  GL_AMBIENT_AND_DIFFUSE, gray);
</code></pre>

<ul>
<li>
<p>Build and test - the plane should appear a light gray</p>
</li>
<li>
<p>Instead of having everything gray, we can turn on colour tracking. Comment out the last two lines, and replace with these:</p>
</li>
</ul>
<pre><code>  glEnable(GL_COLOR_MATERIAL);
  glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
</code></pre>

<ul>
<li>
<p>Build and test - you should have your colours back.</p>
</li>
<li>
<p>Experiment with different values for the ambient light.</p>
</li>
<li>
<p>Try half:</p>
</li>
</ul>
<pre><code>  float  ambientLightHalf[] = { 0.5f, 0.5f, 0.5f, 1.0f };
</code></pre>

<ul>
<li>and default:</li>
</ul>
<pre><code>  float  ambientLightDefault[] = { 0.2f, 0.2f, 0.2f, 1.0f };
</code></pre>

<ul>
<li>Observer the results in each instance</li>
</ul>
	  </section>
	  <section data-tab="step06" class="ui tab stacked clarity-book segment">
	     <h2>06: Normals</h2>
<ul>
<li>
<p>For lighting to function properly, we need to know "which way is up"</p>
</li>
<li>
<p>This requires the computation of Normals.</p>
</li>
<li>
<p>This could be implemented as a global function - say in vector3.cpp. Note however, that this is not a member of Vector3.</p>
</li>
</ul>
<pre><code>Vector3 findNormal(const Vector3&amp;amp; point1, const Vector3&amp;amp; point2, const Vector3&amp;amp; point3)
{
  Vector3 v1, v2;

  // Calculate two vectors from the three points. Assumes counter clockwise winding
  v1.X = point1.X - point2.X;
  v1.Y = point1.Y - point2.Y;
  v1.Z = point1.Z - point2.Z;

  v2.X = point2.X - point3.Z;
  v2.Y = point2.Y - point3.Y;
  v2.Z = point2.Z - point3.Z;

  // Take the cross product of the two vectors to get he normal vector.
  Vector3 result;
  result.X =  v1.Y * v2.Z - v2.Y * v1.Z;
  result.Y = -v1.X * v2.Z + v2.X * v1.Z;
  result.Z =  v1.X * v2.Y - v2.X * v1.Y;
  return result;
}
</code></pre>

<ul>
<li>Our custom render function in jetplane.cpp can be extended to compute and render normals for the triangles:</li>
</ul>
<pre><code>void render (Vector3 vectors[][3], int size)
{
  for (int i=0; i&lt;size; i++)
  {
    glBegin(GL_TRIANGLES);
      Vector3 normal = findNormal( vectors[i][0], vectors[i][1], vectors[i][2]);
      glNormal3f(normal.X, normal.Y, normal.Z);
      vectors[i][0].render();
      vectors[i][1].render();
      vectors[i][2].render();
    glEnd();
  }
}
</code></pre>

<ul>
<li>Build and test. There will be no noticeable difference...yet.</li>
</ul>
	  </section>
	  <section data-tab="step07" class="ui tab stacked clarity-book segment">
	     <h2>07: Light Sources</h2>
<ul>
<li>Lets consolidate the experiments to date into these three functions:</li>
</ul>
<pre><code>void basicAmbient()
{
  GLfloat  ambientLightFull[] = { 1.0f, 1.0f, 1.0f, 1.0f };
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLightFull);
}

void grayMaterial()
{
  float gray[] =  { 0.75f, 0.75f, 0.75f, 1.0f };
  glMaterialfv(GL_FRONT,  GL_AMBIENT_AND_DIFFUSE, gray);
}

void colourTracking()
{
  glEnable(GL_COLOR_MATERIAL);
  glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
}
</code></pre>

<ul>
<li>
<p>Place them in lignts.cpp, and prototype them in lights.h</p>
</li>
<li>
<p>In our initialise method, having first enabled lighting, we can comment calls to these methods in or out to see their effect:</p>
</li>
</ul>
<pre><code>void World::initialize(int width, int height, std::string name)
{
  //...
  glEnable(GL_LIGHTING);
  //basicAmbient();
  grayMaterial();
  colourTracking();
  //...
</code></pre>

<ul>
<li>
<p>`experiment with various combinations of the above functions being enabled/disabled</p>
</li>
<li>
<p>Now, int lights, introduce 2 more functions to control the lighting:</p>
</li>
</ul>
<pre><code>void lightSource()
{
  float  ambientLightModerate[] = { 0.3f, 0.3f, 0.3f, 1.0f };
  float  diffuseLightModerate[] = { 0.7f, 0.7f, 0.7f, 1.0f };

  glLightfv(GL_LIGHT0,GL_AMBIENT,ambientLightModerate);
  glLightfv(GL_LIGHT0,GL_DIFFUSE,diffuseLightModerate);

  glEnable(GL_LIGHT0);
  glEnable(GL_NORMALIZE);
}
</code></pre>

<ul>
<li>and </li>
</ul>
<pre><code>void positionLight()
{
  float lightPos[] = { -50.f, 50.0f, 100.0f, 1.0f };
  glLightfv(GL_LIGHT0,GL_POSITION,lightPos);
}
</code></pre>

<ul>
<li>Try the following combination:</li>
</ul>
<pre><code>  glEnable(GL_LIGHTING);
  //basicAmbient();
  //grayMaterial();
  lightSource();
  colourTracking();
</code></pre>

<ul>
<li>Now try this one</li>
</ul>
<pre><code>  //basicAmbient();
  grayMaterial();
  lightSource();
  //colourTracking();
</code></pre>

<ul>
<li>Now try positioning the light via a call to the positionLight() method somewhere in the render method:</li>
</ul>
<pre><code>void World::render()
{
  Color::Blue.renderClear();
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  if (projectors.isPerspective())
  {
    glLoadIdentity();
    cameras.currentCamera-&gt;render();
  }
  scene-&gt;render();
  glutSwapBuffers();
}
</code></pre>

<ul>
<li>
<p>Where is the best place? Remember to test this your camera will be moving, not the light, so the essential lumination/shadows should not change as you move around the scene.</p>
</li>
<li>
<p>In particular, explore what happens if the light is positioned after the glLoadIdentity() call, but before the camera render.</p>
</li>
<li>
<p>See if you can identify the light source position by view the plan (using the third person camera) from different directions.</p>
</li>
<li>
<p>Move the light source, and see if you can ascertain the difference.</p>
</li>
<li>
<p>Finally, revert to this combination:</p>
</li>
</ul>
<pre><code>  //basicAmbient();
  grayMaterial();
  lightSource();
  //colourTracking();
</code></pre>

<ul>
<li>and, jetplane.cpp, comment out the glNormal function call:</li>
</ul>
<pre><code>void render (Vector3 vectors[][3], int size)
{
  for (int i=0; i&lt;size; i++)
  {
    glBegin(GL_TRIANGLES);
      Vector3 normal = findNormal( vectors[i][0], vectors[i][1], vectors[i][2]);
      //glNormal3f(normal.X, normal.Y, normal.Z);
      vectors[i][0].render();
      vectors[i][1].render();
      vectors[i][2].render();
    glEnd();
  }
}
</code></pre>

<ul>
<li>
<p>Build and test. Can you see the major effect the normals are having?</p>
</li>
<li>
<p>Put the normals back in and test again.</p>
</li>
</ul>
	  </section>
	  <section data-tab="step08" class="ui tab stacked clarity-book segment">
	     <h2>08: Material Properties</h2>
<ul>
<li>Introduce this enmumerated type + function into the lights headder file:</li>
</ul>
<pre><code>enum MaterialTypes {flatRed, flatYellow, flatBlue, flatGreen, flatGray, plasticRed, shinyWhite, brass, bronze,
  chrome, copper, gold, pewter, silver, polishSilver, plasticBlack} ;

void applyMaterial(MaterialTypes material);
</code></pre>

<ul>
<li>In the lights.cpp file, introduce this data structure:</li>
</ul>
<pre><code>struct Material
{
  GLfloat ambient[4];
  GLfloat diffuse[4];
  GLfloat specular[4];
  GLfloat shiny;
};
</code></pre>

<ul>
<li>Now define this table:</li>
</ul>
<pre><code>Material materials [] =
{
    { {0.8, 0.0, 0.0, 1.0}, // flatRed
      {0.8, 0.0, 0.0, 1.0},
      {0.8, 0.0, 0.0, 1.0}, 25.0 },

    { {0.8, 0.0, 0.0, 1.0}, //flatYellow
      {0.8, 0.0, 0.0, 1.0},
      {0.8, 0.0, 0.0, 1.0}, 25.0 },

    { {0.0, 0.0, 0.8, 1.0}, // flatblue
      {0.0, 0.0, 0.8, 1.0},
      {0.0, 0.0, 0.8, 1.0}, 25.0 },

    { {0.0, 0.8, 0.0, 1.0}, // flatgreen
      {0.0, 0.8, 0.0, 1.0},
      {0.0, 0.8, 0.0, 1.0}, 25.0 },

    { {0.5, 0.5, 0.5, 1.0}, // flatgrey
      {0.5, 0.5, 0.5, 1.0},
      {0.5, 0.5, 0.5, 1.0}, 25.0 },

    { {0.3, 0.0, 0.0, 1.0}, //plasticRed
      {0.6, 0.0, 0.0, 1.0},
      {0.8, 0.6, 0.6, 1.0}, 32.0 },

    { {1.0, 1.0, 1.0, 1.0}, //shinyWhite
      {1.0, 1.0, 1.01, 1.0},
      {1.0, 1.0, 1.0, 1.0}, 100.0 },

    { {0.329412, 0.223529, 0.027451, 1.0}, //brass
      {0.780392, 0.568627, 0.113725, 1.0},
      {0.9922157, 0.941176, 0.807843, 1.0}, 27.8974 },

    { {0.2125, 0.1275, 0.054, 1.0}, //bronze
      {0.714, 0.4284, 0.18144, 1.0},
      {0.303548, 0.271906, 0.106721, 1.0}, 25.6 },

    { {0.25, 0.25, 0.25, 1.0}, //chrome
      {0.4, 0.4, 0.4, 1.0},
      {0.774597, 0.774597, 0.774597, 1.0}, 76.8 },

    { {0.19125, 0.0735, 0.0225, 1.0}, //copper
      {0.7038, 0.27048, 0.0828, 1.0},
      {0.256777, 0.137622, 0.086014, 1.0},  12.8 },

    { {0.24725, 0.1995, 0.0745, 1.0},// gold
      {0.75164, 0.60648, 0.22658, 1.0},
      {0.628281, 0.555802, 0.366065, 1.0},  51.2 },

    { {0.10558, 0.058824, 0.113725, 1.0}, //pewter
      {0.427451, 0.470588, 0.541176, 1.0},
      {0.3333, 0.3333, 0.521569, 1.0}, 9.84615 },

    { {0.19225, 0.19225, 0.19225, 1.0}, //silver
      {0.50754, 0.50754, 0.50754, 1.0},
      {0.508273, 0.508273, 0.508273, 1.0}, 51.2 },

    { {0.23125, 0.23125, 0.23125, 1.0}, //polishSilver
      {0.2775, 0.2775, 0.2775, 1.0},
      {0.773911, 0.773911, 0.773911, 1.0}, 89.6 },

    { {0.0, 0.0, 0.0, 1.0}, //plasticBlack
      {0.01, 0.01, 0.01, 1.0},
      {0.50, 0.50, 0.50, 1.0},32.0 }
};
</code></pre>

<ul>
<li>and this implementation of the applyMaterial fiunction:</li>
</ul>
<pre><code>void applyMaterial(MaterialTypes material)
{
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,   materials[material].ambient);
  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,   materials[material].diffuse);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  materials[material].specular);
  glMaterialf (GL_FRONT_AND_BACK, GL_SHININESS, materials[material].shiny);
}
</code></pre>

<ul>
<li>Experiment with these material properties in the jet plane geometry - try setting different properties for each of the segments.</li>
</ul>
	  </section>
	  <section data-tab="step09" class="ui tab stacked clarity-book segment">
	     <h2>08: Exercises</h2>
<h2>Solution:</h2>
<ul>
<li>
<p>This is the completed lab to date:</p>
</li>
<li>
<p><a href="../archives/lab10_lighting.zip">lab10_lighting.zip</a></p>
</li>
</ul>
<h2>Exercise 1</h2>
<ul>
<li>These are all of the lighting functions we have been using:</li>
</ul>
<pre><code>void basicAmbient()
{
  GLfloat  ambientLightFull[] = { 1.0f, 1.0f, 1.0f, 1.0f };
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLightFull);
}

void grayMaterial()
{
  float gray[] =  { 0.75f, 0.75f, 0.75f, 1.0f };
  glMaterialfv(GL_FRONT,  GL_AMBIENT_AND_DIFFUSE, gray);
}

void colourTracking()
{
  glEnable(GL_COLOR_MATERIAL);
  glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
}

void lightSource()
{
  float  ambientLightModerate[] = { 0.3f, 0.3f, 0.3f, 1.0f };
  float  diffuseLightModerate[] = { 0.7f, 0.7f, 0.7f, 1.0f };

  glLightfv(GL_LIGHT0,GL_AMBIENT,ambientLightModerate);
  glLightfv(GL_LIGHT0,GL_DIFFUSE,diffuseLightModerate);

  glEnable(GL_LIGHT0);
  glEnable(GL_NORMALIZE);
}

void positionLight()
{
  float lightPos[] = { -50.f, 50.0f, 100.0f, 1.0f };
  glLightfv(GL_LIGHT0,GL_POSITION,lightPos);
}
</code></pre>

<ul>
<li>Encapsulate these into a class Light - and incorporate into our world model</li>
</ul>
<h2>Exercise 2</h2>
<p>Devise a mechanism where by you can control the light by some key combination. These controls could:
- Control ambient light intensity</p>
<ul>
<li>
<p>Control the diffuse light intensity</p>
</li>
<li>
<p>Move the light</p>
</li>
</ul>
	  </section>
	<br>


	<div class="ui fixed bottom borderless menu">'
	  <div class="ui small item"> 
	  <p id="footertext">
	  Prepared by  Eamonn de leastar (edeleastar@wit.ie). Except where otherwise noted, this content is licensed under a  
	   <a  href="http://creativecommons.org/licenses/by-nc/4.0/" title="External link to http://creativecommons.org/licenses/by-nc/4.0/" 
	     target="_blank">Creative Commons Attribution-NonCommercial 4.0 License
	   </a>
	   </p>
	  </div>
	</div>


  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49354439-4', 'edeleastar.github.io');
    ga('send', 'pageview');
  </script> </body>
 </html>