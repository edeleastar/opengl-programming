#include "sphereactor.h"
#include "cmath"

using namespace std;

SphereActor::SphereActor(Geometry *geometry)
: PhysicsActor(geometry)
{

    std::cout <<"Creating sphere " <<geometry->name <<std::endl;
    
    // STEP 1
    //
    // Use faces/vertices geomerty to determine 
    // the shape, dimensions and position and orientation.
    
    // first pass over vertices to determine position (centre)
    position = Vector3::zero();
    unsigned int vertexCount = 0;
    foreach (Vector3 &vector, geometry->vertices)
    {
        position += vector;
        ++vertexCount;
    }
    position /= float(vertexCount);
    std::cout <<"\t Position is " <<position <<std::endl;
 
    // second pass over vertices to deterine radius
    // we could just take a sample (or even jsut the first point)
    // but there is quite a lot of variation in the points generated by maya.
    radius = 0.0f;
    foreach (Vector3 &vector, geometry->vertices)
    {
        radius += (position-vector).length();
    }
    radius /= float(vertexCount);
    std::cout <<"\t Radius is " <<radius <<std::endl;

    // Given sphere's symmetry the initial orientation is taken as zero.
    std::cout <<"\t Orientation is " <<orientation <<std::endl;

 
    // STEP 2
    //
    // Get non-geometrical settings from second data file.
    // These are hard coded here as I am lazy/Eamon is not paying enough.

    velocity = Vector3(0,1,0);
    acceleration = Vector3(0,-.1,0);
//    position = Vector3::zero();
    inverseMass = 1.0f;
    damping = 1.0f;
    
    // specify the inertia tensoer for a sphere
    // see Game Physics Engine, page 432
    float tmp = inverseMass * 2.5f / (radius*radius);
    inverseInertiaTensor = Matrix3(tmp,0,0, 0,tmp,0, 0,0,tmp);
    
    // STEP 3
    // Update geometry based on object physical properties
    //
    // At a minimum the vertices are given relative to the object's 
    // position and orientation.

    foreach (Vector3 &vector, geometry->vertices)
    {
        vector -= position;
    }
    
}

