 <!DOCTYPE html>
 <html>
   <head>
     <meta charset="utf-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
   
     <title> Lab-12-A </title>
   
     <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
     <link rel="stylesheet" href="./style/semantic/css/semantic.min.css" type="text/css">  
     <link rel="stylesheet" href="./style/custom/main.css" type="text/css"> 
   
     <script src="./style/custom/jquery-2.1.0.min.js"></script> 
     <script src="./style/custom/jquery.address-1.6.min.js"></script>
     <script src="./style/semantic/javascript/semantic.min.js"></script>
   
     <link rel="stylesheet" href="./style/highlight/school_book.css">
     <script src="./style/highlight/highlight.pack.js"></script> 
     <script>hljs.initHighlightingOnLoad();</script>
   
     <script src="./style/custom/common.js"> </script> 
     <script src="./style/custom/main.js"> </script> 
  </head>
  <body>
  <nav class="ui fixed top pointing borderless inverted menu">
    <header class="header item"> <a href="../index.html">VBOs & Textures</a></header>
    <div class="right tab-menu menu">
          <a class="item" data-tab="Lab-12-A"> Lab-12-A </a>
          <a class="item" data-tab="01"> 01 </a>
          <a class="item" data-tab="02"> 02 </a>
          <a class="item" data-tab="03"> 03 </a>
          <a class="item" data-tab="04"> 04 </a>
          <a class="item" data-tab="05"> 05 </a>
          <a class="item" data-tab="06"> 06 </a>
          <a class="item" data-tab="Exercises"> Exercises </a>
    </div>
  </nav>

  <br>

	  <section data-tab="Lab-12-A" class="ui tab stacked moodle-book segment">
	     <h1>Objectives</h1>
<ul>
<li>Factor out the current Geometry class into an abstract base class and an ImmediateGeometry that encapsulates current functionality<ul>
<li>Derive a new class - VaGeometry - which uses Vertex Arrays</li>
<li>Derive another class - ElementGeometry - which uses indexed Vertex Arrays</li>
<li>Derive a class from ElementGeometry called VboGeometry which employs Vertex Buffer Objects</li>
</ul>
</li>
<li>Instrument all of these classes to track number of vertices rendered</li>
</ul>
	  </section>
	  <section data-tab="01" class="ui tab stacked moodle-book segment">
	     <h1>Setup</h1>
<ul>
<li>
<p>Use the solution to lab11b, or clone this project here:</p>
</li>
<li>
<p><a href="archives/lab11a_modelling.zip">lab11a_modelling.zip</a></p>
</li>
<li>
<p>..and call it lab12c_vbo</p>
</li>
</ul>
	  </section>
	  <section data-tab="02" class="ui tab stacked moodle-book segment">
	     <h1>ImmediateGeometry</h1>
<h2>Geometry</h2>
<ul>
<li>Currently the Geometry class uses stl::map - this is the non-polymorphic standard version. We will convert this to the boost::ptr_map, the polymorphic container was are already using elsewhere:</li>
</ul>
<pre><code>//typedef std::map &lt;std::string, Geometry&gt;  GeometryMap;
typedef boost::ptr_map &lt;std::string, Geometry&gt;  GeometryMap;
</code></pre>

<ul>
<li>Additionally, Geometry itself is to become abstract - the render() and extractVertices() methods are to be made pure virtual:</li>
</ul>
<pre><code>  virtual void render()=0;
  virtual void extractVertices()=0;
</code></pre>

<ul>
<li>Delete these methods from the geometry implementation. Also, delete the call to extracrVertices() from the constructor:</li>
</ul>
<pre><code>  ///extractVertices();
</code></pre>

<ul>
<li>We will call this manually from load.</li>
</ul>
<h2>ImmediateGeometry</h2>
<ul>
<li>Our current implementation of these methods is to be factored out into a new class called "ImmediateGeometry"</li>
</ul>
<pre><code>#pragma once
#include &quot;geometry.h&quot;

struct ImmediateGeometry : public Geometry
{
  ImmediateGeometry();
  ImmediateGeometry(std::string name, std::istream&amp;amp;, VertexGroup*);

  void render();
  void extractVertices();
};
</code></pre>

<pre><code>#include &quot;immediategeometry.h&quot;
using namespace std;

ImmediateGeometry::ImmediateGeometry()
{
}

ImmediateGeometry::ImmediateGeometry(string groupName, istream&amp;amp; is, VertexGroup*group)
: Geometry (groupName, is, group)
{
}

void ImmediateGeometry::render()
{
  foreach (Face &amp;amp;face, faces)
  {
    face.render(vertices);
  }
}

void ImmediateGeometry::extractVertices()
{
  int newIndex=0;
  foreach (Face &amp;amp;face, faces)
  {
    vector&lt;int&gt; groupIndices = face.vertexIndices;
    face.vertexIndices.clear();
    foreach (int index, groupIndices)
    {
      Vector3 vertex(vertexGroup-&gt;vertices[index-1].X, vertexGroup-&gt;vertices[index-1].Y, vertexGroup-&gt;vertices[index-1].Z);
      vertices.push_back(vertex);
      face.vertexIndices.push_back(newIndex);
      newIndex++;
    }
  }
}
</code></pre>

<h2>AnimateScene</h2>
<ul>
<li>
<p>The signatures of the SphereActor constructor will change - as the geometry map is now a map of pointers (not references).</p>
</li>
<li>
<p>In AnimateScene::loadActor change the following:</p>
</li>
</ul>
<pre><code>Actor* AnimateScene::loadActor(GeometryMap::value_type &amp;amp;value)
{
  //...
    //PhysicsActor * sphere = new SphereActor(&amp;amp;value.second);
    PhysicsActor * sphere = new SphereActor(value.second);
  // ...
    //actor = new SphereActor(&amp;amp;value.second);
    actor = new SphereActor(value.second);
  //...
}
</code></pre>

<h2>Scene</h2>
<ul>
<li>In Scene - a similar adjustment:</li>
</ul>
<pre><code>void Scene::loadActors(Model*model)
{
  //...
  //foreach (GeometryMap::value_type &amp;amp;value, model-&gt;entities)
  foreach (GeometryMap::value_type value, model-&gt;entities)
  //...
}

Actor* Scene::loadActor(GeometryMap::value_type &amp;amp;value)
{
  //return new Actor(&amp;amp;value.second);
  return new Actor(value.second);
}
</code></pre>

<h2>Model</h2>
<ul>
<li>Finally, in Model we make similar changes to the render method:</li>
</ul>
<pre><code>void Model::render()
{
  //foreach (GeometryMap::value_type &amp;amp;value, entities)
  //{
  //  value.second.render();
  //}
  foreach (GeometryMap::value_type value, entities)
  {
    value.second-&gt;render();
  }
}
</code></pre>

<ul>
<li>and we create ImmediateGeometry instead of geometry:</li>
</ul>
<pre><code>        //Geometry a(name, is, &amp;amp;defaultGroup);
        //if (entities.find(a.name) == entities.end())
        //{
        //  entities[a.name] = a;
        //}
        Geometry *geometry = new ImmediateGeometry(name, is, &amp;amp;defaultGroup);
        geometry-&gt;extractVertices();
        if (entities.find(geometry-&gt;name) == entities.end())
        {
          entities.insert(geometry-&gt;name, geometry);
        }
</code></pre>

<h2>Build</h2>
<ul>
<li>Build and test - there should be no difference from the last version</li>
</ul>
	  </section>
	  <section data-tab="03" class="ui tab stacked moodle-book segment">
	     <h1>Triangulate Model</h1>
<ul>
<li>
<p>Before we move away form immediate mode, we need to make some adjustments to our models.</p>
</li>
<li>
<p>The default in Maya is to use a combination of quads and triangles. For a simple cube:</p>
</li>
</ul>
<p><img alt="" src="img/01.png"></p>
<ul>
<li>This will be quads:</li>
</ul>
<pre><code>g default
v -1.817879 0.000000 2.020566
v 1.621435 0.000000 2.020566
v -1.817879 1.425117 2.020566
v 1.621435 1.425117 2.020566
v -1.817879 1.425117 0.190042
v 1.621435 1.425117 0.190042
v -1.817879 0.000000 0.190042
v 1.621435 0.000000 0.190042
vt 0.375000 0.000000
vt 0.625000 0.000000
vt 0.375000 0.250000
vt 0.625000 0.250000
vt 0.375000 0.500000
vt 0.625000 0.500000
vt 0.375000 0.750000
vt 0.625000 0.750000
vt 0.375000 1.000000
vt 0.625000 1.000000
vt 0.875000 0.000000
vt 0.875000 0.250000
vt 0.125000 0.000000
vt 0.125000 0.250000
g pCube1
f 1/1 2/2 4/4 3/3
f 3/3 4/4 6/6 5/5
f 5/5 6/6 8/8 7/7
f 7/7 8/8 2/10 1/9
f 2/2 8/11 6/12 4/4
f 7/13 1/1 3/3 5/14
</code></pre>

<ul>
<li>
<p>If we wish to use alternatives to immediate mode, we will require that all geometry is constructed using triangles only.</p>
</li>
<li>
<p>Maya can be persuaded to 'triangulate' a model. To this, select "Polygons" in the top left:</p>
</li>
</ul>
<p><img alt="" src="img/02.png"></p>
<ul>
<li>then, having selected the polygon, select "Triangulate" from the 'Mesh' menu:</li>
</ul>
<p><img alt="" src="img/03.png"></p>
<ul>
<li>This will triangulate the model:</li>
</ul>
<p><img alt="" src="img/04.png"></p>
<ul>
<li>This is clear from the OBJ format:</li>
</ul>
<pre><code>g default
v -1.817879 0.000000 2.020566
v 1.621435 0.000000 2.020566
v -1.817879 1.425117 2.020566
v 1.621435 1.425117 2.020566
v -1.817879 1.425117 0.190042
v 1.621435 1.425117 0.190042
v -1.817879 0.000000 0.190042
v 1.621435 0.000000 0.190042
vt 0.375000 0.000000
vt 0.625000 0.000000
vt 0.375000 0.250000
vt 0.625000 0.250000
vt 0.375000 0.500000
vt 0.625000 0.500000
vt 0.375000 0.750000
vt 0.625000 0.750000
vt 0.375000 1.000000
vt 0.625000 1.000000
vt 0.875000 0.000000
vt 0.875000 0.250000
vt 0.125000 0.000000
vt 0.125000 0.250000
g pCube1
f 1/1 2/2 3/3
f 3/3 2/2 4/4
f 3/3 4/4 5/5
f 5/5 4/4 6/6
f 5/5 6/6 7/7
f 7/7 6/6 8/8
f 7/7 8/8 1/9
f 1/9 8/8 2/10
f 2/2 8/11 4/4
f 4/4 8/11 6/12
f 7/13 1/1 5/14
f 5/14 1/1 3/3
</code></pre>
	  </section>
	  <section data-tab="04" class="ui tab stacked moodle-book segment">
	     <h1>VaGeometry</h1>
<ul>
<li>Introduce the following specialisation of Geometry:</li>
</ul>
<pre><code>#pragma once
#include &quot;geometry.h&quot;

struct VaGeometry : public Geometry
{
  std::vector&lt;float&gt; rawVertices;

  VaGeometry();
  VaGeometry(std::string name, std::istream&amp;amp;, VertexGroup*);

  void render();
  void extractVertices();
};
</code></pre>

<ul>
<li>With this implementation:</li>
</ul>
<pre><code>#include &quot;VaGeometry.h&quot;
using namespace std;

VaGeometry::VaGeometry()
{
}

VaGeometry::VaGeometry(string groupName, istream&amp;amp; is, VertexGroup*group)
: Geometry (groupName, is, group)
{
}

void VaGeometry::render()
{
  glEnableClientState(GL_VERTEX_ARRAY);

  glVertexPointer(3, GL_FLOAT, 0, &amp;amp;rawVertices[0]);
  glDrawArrays(GL_TRIANGLES, 0, rawVertices.size()/3);

  glDisableClientState(GL_VERTEX_ARRAY);
}

void VaGeometry::extractVertices()
{
  foreach (Face &amp;amp;face, faces)
  {
    foreach (int index, face.vertexIndices)
    {
      Vector3 vertex(vertexGroup-&gt;vertices[index-1].X, vertexGroup-&gt;vertices[index-1].Y, vertexGroup-&gt;vertices[index-1].Z);
      rawVertices.push_back(vertex.X);
      rawVertices.push_back(vertex.Y);
      rawVertices.push_back(vertex.Z);
    }
  }
}
</code></pre>

<ul>
<li>Now change the model to use this class instead of the ImmediateGeometry:</li>
</ul>
<pre><code>  //Geometry *geometry = new ImmediateGeometry(name, is, &amp;amp;defaultGroup);
  Geometry *geometry = new VaGeometry(name, is, &amp;amp;defaultGroup);
</code></pre>

<ul>
<li>
<p>For test purposes, use this model here. They have already been triangulated (check this).</p>
</li>
<li>
<p><a href="archives/model.mb|./model.mb">model.mb|./model.mb</a></p>
</li>
<li>
<p><a href="archives/model.obj|./model.obj">model.obj|./model.obj</a></p>
</li>
<li>
<p>We will introduce some instrumentation into the rendering - so we can keep track of the number of vertices being rendered.</p>
</li>
<li>
<p>Into the end of extractVertices, place the following code fragment:</p>
</li>
</ul>
<pre><code>  static int totalVertices = 0;
  totalVertices += rawVertices.size();
  cout &lt;&lt; &quot;Vertices for &quot; &lt;&lt; name &lt;&lt; ':' &lt;&lt; rawVertices.size() &lt;&lt; endl;
  cout &lt;&lt; &quot;total vertices to date: &quot; &lt;&lt; totalVertices &lt;&lt; endl;
</code></pre>

<ul>
<li>For the above model, this should generate these metrics:</li>
</ul>
<pre><code>Vertices for pCube1:108
total vertices to date: 108
Vertices for pSphere1:6840
total vertices to date: 6948
Vertices for pTorus1:7200
total vertices to date: 14148
</code></pre>

<ul>
<li>As an experiment, we can also instrument the ImmediateGeometry class - place this fragment in its extractVertices method:</li>
</ul>
<pre><code>  static int totalVertices = 0;
  totalVertices += rawVertices.size();
  cout &lt;&lt; &quot;Vertices for &quot; &lt;&lt; name &lt;&lt; ':' &lt;&lt; rawVertices.size() &lt;&lt; endl;
  cout &lt;&lt; &quot;total vertices to date: &quot; &lt;&lt; totalVertices &lt;&lt; endl;
</code></pre>

<ul>
<li>Have the model use the ImmediateGeometry instead - and observe the metrics:</li>
</ul>
<pre><code>Vertices for pCube1:36
total vertices to date: 36
Vertices for pSphere1:2280
total vertices to date: 2316
Vertices for pTorus1:2400
total vertices to date: 4716
</code></pre>

<ul>
<li>A substantial difference - can you explain it?</li>
</ul>
	  </section>
	  <section data-tab="05" class="ui tab stacked moodle-book segment">
	     <h1>ElementGeometry</h1>
<ul>
<li>Introduce the folllowing class into the model:</li>
</ul>
<pre><code>#pragma once
#include &quot;geometry.h&quot;

struct Elements
{
  std::vector&lt;float&gt; vertices;
  std::vector&lt;GLushort&gt;   indices;
};

struct ElementGeometry : public Geometry
{
  Elements elements;

  ElementGeometry();
  ElementGeometry(std::string name, std::istream&amp;amp;, VertexGroup*);

  void render();
  void extractVertices();
};
</code></pre>

<pre><code>#include &quot;elementgeometry.h&quot;
using namespace std;

ElementGeometry::ElementGeometry()
{
}

ElementGeometry::ElementGeometry(string groupName, istream&amp;amp; is, VertexGroup*group)
: Geometry (groupName, is, group)
{
}

void ElementGeometry::render()
{
  glEnableClientState(GL_VERTEX_ARRAY);

  glVertexPointer(3, GL_FLOAT, 0, &amp;amp;elements.vertices[0]);
  glDrawElements(GL_TRIANGLES, elements.indices.size(), GL_UNSIGNED_SHORT, &amp;amp;elements.indices[0]);

  glDisableClientState(GL_VERTEX_ARRAY);
}

void ElementGeometry::extractVertices()
{
  typedef map &lt;GLushort,GLushort&gt; IndexMap;
  IndexMap indexMap;
  int newIndex=0;
  foreach (Face &amp;amp;face, faces)
  {
    foreach (int index, face.vertexIndices)
    {
      Vector3 vertex(vertexGroup-&gt;vertices[index-1].X, vertexGroup-&gt;vertices[index-1].Y, vertexGroup-&gt;vertices[index-1].Z);
      if (indexMap.find(index) == indexMap.end())
      {
        indexMap[index] = newIndex;
        elements.vertices.push_back(vertex.X);
        elements.vertices.push_back(vertex.Y);
        elements.vertices.push_back(vertex.Z);
        elements.indices.push_back(newIndex);
        newIndex++;
      }
      else
      {
        elements.indices.push_back(indexMap[index]);
      }
    }
  }

  static int totalVertices = 0;
  totalVertices += elements.vertices.size();
  cout &lt;&lt; &quot;Vertices for &quot; &lt;&lt; name &lt;&lt; ':' &lt;&lt; elements.vertices.size() &lt;&lt; endl;
  cout &lt;&lt; &quot;total vertices to date: &quot; &lt;&lt; totalVertices &lt;&lt; endl;
}
</code></pre>

<ul>
<li>Use this class in model load and verify that the scene is rendered. You should see these metrics:</li>
</ul>
<pre><code>Vertices for pCube1:24
total vertices to date: 24
Vertices for pSphere1:1146
total vertices to date: 1170
Vertices for pTorus1:1200
total vertices to date: 2370
</code></pre>

<ul>
<li>Contrast the total number of vertices for ImmediateGeometry</li>
</ul>
<pre><code>total vertices to date: 4716
</code></pre>

<ul>
<li>and VaGeometry</li>
</ul>
<pre><code>total vertices to date: 14148
</code></pre>

<ul>
<li>Again, can you explain the difference?</li>
</ul>
	  </section>
	  <section data-tab="06" class="ui tab stacked moodle-book segment">
	     <h1>VboGeometry</h1>
<ul>
<li>Finally, the VboGeometry class:</li>
</ul>
<pre><code>#pragma once
#include &quot;elementgeometry.h&quot;

struct VboGeometry : public ElementGeometry
{
  GLuint ids[2];

  VboGeometry();
  VboGeometry(std::string name, std::istream&amp;amp;, VertexGroup*);

  void render();
  void extractVertices();
};
</code></pre>

<ul>
<li>Note that it is derived from ElementGeometry</li>
</ul>
<pre><code>#include &quot;VboGeometry.h&quot;
using namespace std;

VboGeometry::VboGeometry()
{
}

VboGeometry::VboGeometry(string groupName, istream&amp;amp; is, VertexGroup*group)
: ElementGeometry (groupName, is, group)
{
}

void VboGeometry::render()
{
  glBindBufferARB(GL_ARRAY_BUFFER, ids[0]);
  glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER, ids[1]);

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, 0);
  glDrawElements(GL_TRIANGLES, elements.indices.size(), GL_UNSIGNED_SHORT, 0);
  glDisableClientState(GL_VERTEX_ARRAY);

  glBindBuffer(GL_ARRAY_BUFFER, 0);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

void VboGeometry::extractVertices()
{
  ElementGeometry::extractVertices();

  glGenBuffers(2, ids);

  glBindBuffer(GL_ARRAY_BUFFER, ids[0]);
  glBufferData(GL_ARRAY_BUFFER, elements.vertices.size()*sizeof(float), &amp;amp;elements.vertices[0], GL_STATIC_DRAW);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ids[1]);
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements.indices.size()*sizeof(GLushort), &amp;amp;elements.indices[0], GL_STATIC_DRAW);
}
</code></pre>

<ul>
<li>
<p>Build and test</p>
</li>
<li>
<p>As it is using the ElementGeometry class, its metrics are the same.</p>
</li>
</ul>
	  </section>
	  <section data-tab="Exercises" class="ui tab stacked moodle-book segment">
	     <h1>Exercises</h1>
<ul>
<li>
<p>What impact does using the VBO classes have on our physics simulation?</p>
</li>
<li>
<p>Currently, you will note that the Physics classes use Geometry-&gt;vertices</p>
</li>
<li>
<p>Are these still relevant for VboGeometry?</p>
</li>
<li>
<p>If changes are made to these vertices - do they have any effect on the rendering?</p>
</li>
</ul>
	  </section>
  <div class="ui fixed bottom borderless menu">'
    <div class="ui small item"> 
    <p id="footertext">
    Prepared by  Eamonn de Leastar (edeleastar@wit.ie). Except where otherwise noted, this content is licensed under a  
     <a  href="http://creativecommons.org/licenses/by-nc/4.0/" title="External link to http://creativecommons.org/licenses/by-nc/4.0/" 
       target="_blank">Creative Commons Attribution-NonCommercial 4.0 License
     </a>
     </p>
    </div>
  </div>   
    
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-49703418-6']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>  </body>
 </html>